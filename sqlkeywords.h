#ifndef SQLKEYWORDS_H_INCLUDED
#define SQLKEYWORDS_H_INCLUDED

/*Because I want to give multiple ways for the user to be able to generate sql queries, the following set of enums and
structures are meant to allow the user to call a funtion with a couple of settings and obtain a full sql query out of it.
This is not a perfect system and requires hardcoding of all possible combination of switches, but it should simplify
query generation for very simple queries! :D
*/

#include <string>
#include <map>
#include <iostream>
#include "typedefs.h"

typedef unsigned short word;

/*Keywords enumerated in 16bit word format. The idea is that, if you want to build a statement, you can pass to statementType
in the generator multiple keywords in the format x|y|z. Thus, the SQL statement SELECT * FROM y can be generated by evaluating
whether statementType = SELECT | FROM. Since this is a binary OR evaluation, you obtain a value that is a merged version of
SELECT and FROM binary values! :D
*/
//To guard against defined macros
#undef DELETE
#undef IN
enum StatementTypes
{
    CREATETABLE =   0x0001,
    SELECT =        0x0002,
    INSERT =        0x0004,
    DELETE =        0x0008,
    WHERE =         0x0010,
    AS =            0x0020,
    CALL =          0x0040,
    FROM =          0x0080,
    TO =            0x0100,
    UPDATE =        0x0200,
    AND =           0x0400,
    OR =            0x0800,
    LIKE =          0x1000,
    CREATEDATABASE =0x2000,
    INTO =          0x4000,
    IN =            0x8000,
    ALL =           UPDATE | INSERT | AND | OR,
    AOR =           AND | OR, //Substitute for the AND OR keyword combination
    ORDERBY =       IN | TO | UPDATE,
    VALUES =        LIKE | AS,
    SET =           UPDATE | INTO,
    AS_TABLE =      AS | CREATETABLE,
    INNER_JOIN =    INSERT | IN,
    ON =            AS | AND,
    JOIN =          INNER_JOIN,
    LEFT_JOIN =     JOIN | OR,
    LEFT_OUTER_JOIN=LEFT_JOIN,
    BETWEEN =       IN | VALUES,
    RIGHT_JOIN =    JOIN | CALL,
    RIGHT_OUTER_JOIN=RIGHT_JOIN,
    FULL_JOIN =     JOIN | CALL | OR,
    FULL_OUTER_JOIN=FULL_JOIN,
    INTO_SELECT =   INTO | SELECT | CALL,
    UNION =         AS | LIKE | INTO,
};

/*The following map is used by the generators to quickly generate the query statement while using as little memory as
possible. In other words, the compiler doesn't have to add assembly code every time I write SELECT in the switch statement.
The program doesn't have to allocate memory for each SELECT either! The users can also use this map in their custom
generator implementations.
*/
static std::map<word, std::string> Keywords{
    {CREATETABLE    , "CREATE TABLE \0"},
    {SELECT         , "SELECT \0"},
    {INSERT         , "INSERT \0"},
    {DELETE         , "DELETE \0"},
    {WHERE          , "WHERE \0"},
    {AS             , "AS \0"},
    {CALL           , "CALL \0"},
    {FROM           , "FROM \0"},
    {TO             , "TO \0"},
    {UPDATE         , "UPDATE \0"},
    {AND            , "AND \0"},
    {OR             , "OR \0"},
    {LIKE           , "LIKE \0"},
    {CREATEDATABASE , "CREATEDATABASE \0"},
    {INTO           , "INTO \0"},
    {IN             , "IN \0"},
    {ORDERBY        , "ORDER BY \0"},
    {VALUES         , "VALUES \0"},
    {SET            , "SET \0"},
    {INNER_JOIN     , "INNER JOIN \0"},
    {ON             , "ON \0"},
    {LEFT_JOIN      , "LEFT JOIN \0"},
    {BETWEEN        , "BETWEEN \0"},
    {RIGHT_JOIN     , "RIGHT JOIN \0"},
    {FULL_JOIN      , "FULL OUTER JOIN \0"},
    {UNION          , "UNION \0"},
    {ALL            , "ALL \0"},
};


typedef struct SQLGenerator//SQL Query Generator. It's a nice helping structure!
{
    static const std::string WILDCARD;
    std::string prepareStatement(std::string table = WILDCARD, std::string columns = WILDCARD, std::string criteria = WILDCARD, std::string pattern = WILDCARD, std::string pattern2 = WILDCARD, size_t statementType = SELECT);
}SQLQuery;

#endif // SQLKEYWORDS_H_INCLUDED
